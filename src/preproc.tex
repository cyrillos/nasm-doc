\chapter{The NASM \textindexlc{Preprocessor}}
\label{ch:preproc}

NASM contains a powerful \textindex{macro processor}, which supports
conditional assembly, multi-level file inclusion, two forms of macro
(single-line and multi-line), and a ``context stack'' mechanism for
extra macro power. Preprocessor directives all begin with a \code{\%}
sign.

The preprocessor collapses all lines which end with a backslash
\code{\textbackslash\textbackslash} character into a single line.  Thus:

\begin{lstlisting}
	%define THIS_VERY_LONG_MACRO_NAME_IS_DEFINED_TO \\
	        THIS_VALUE
\end{lstlisting}

will work like a single-line macro without the backslash-newline
sequence.

\section{\textindexlc{Single-Line Macros}}
\label{sec:slmacro}

\subsection{The Normal Way: \indexcode{\%idefine}\codeindex{\%define}}
\label{subsec:define}

Single-line macros are defined using the \code{\%define} preprocessor
directive. The definitions work in a similar way to C; so you can do
things like

\begin{lstlisting}
	%define ctrl    0x1F &
	%define param(a,b) ((a)+(a)*(b))

		mov     byte [param(2,ebx)], ctrl 'D'
\end{lstlisting}

which will expand to

\begin{lstlisting}
	mov     byte [(2)+(2)*(ebx)], 0x1F & 'D'
\end{lstlisting}

When the expansion of a single-line macro contains tokens which
invoke another macro, the expansion is performed at invocation time,
not at definition time. Thus the code

\begin{lstlisting}
	%define a(x)    1+b(x)
	%define b(x)    2*x

	mov     ax,a(8)
\end{lstlisting}

will evaluate in the expected way to \code{mov ax,1+2*8}, even though
the macro \code{b} wasn't defined at the time of definition of \code{a}.

Macros defined with \code{\%define} are \textindex{case sensitive}: after
\code{\%define foo bar}, only \code{foo} will expand to \code{bar}:
\code{Foo} or \code{FOO} will not. By using \code{\%idefine} instead of
\code{\%define} (the ``i'' stands for ``insensitive'') you can define
all the case variants of a macro at once, so that \code{\%idefine foo bar}
would cause \code{foo}, \code{Foo}, \code{FOO}, \code{fOO} and so on
all to expand to \code{bar}.

There is a mechanism which detects when a macro call has occurred as
a result of a previous expansion of the same macro, to guard against
\textindex{circular references} and infinite loops. If this happens,
the preprocessor will only expand the first occurrence of the macro.
Hence, if you code

\begin{lstlisting}
	%define a(x)    1+a(x)

		mov     ax,a(3)
\end{lstlisting}

the macro \code{a(3)} will expand once, becoming \code{1+a(3)}, and will
then expand no further. This behaviour can be useful: see \fullref{sec:32c}
for an example of its use.

You can \index{overloading, single-line macros}overload single-line
macros: if you write

\begin{lstlisting}
	%define foo(x)   1+x
	%define foo(x,y) 1+x*y
\end{lstlisting}

the preprocessor will be able to handle both types of macro call,
by counting the parameters you pass; so \code{foo(3)} will become
\code{1+3} whereas \code{foo(ebx,2)} will become \code{1+ebx*2}.
However, if you define

\begin{lstlisting}
	%define foo bar
\end{lstlisting}

then no other definition of \code{foo} will be accepted: a macro with
no parameters prohibits the definition of the same name as a macro
\emph{with} parameters, and vice versa.

This doesn't prevent single-line macros being \emph{redefined}: you can
perfectly well define a macro with

\begin{lstlisting}
	%define foo bar
\end{lstlisting}

and then re-define it later in the same source file with

\begin{lstlisting}
	%define foo baz
\end{lstlisting}

Then everywhere the macro \code{foo} is invoked, it will be expanded
according to the most recent definition. This is particularly useful
when defining single-line macros with \code{\%assign}
(see \fullref{sec:assign}).

You can \textindex{pre-define} single-line macros using the \code{-d}
option on the NASM command line: see \fullref{sec:opt-d}.
