\chapter{The NASM \textindexlc{Preprocessor}}
\label{ch:preproc}

NASM contains a powerful \textindex{macro processor}, which supports
conditional assembly, multi-level file inclusion, two forms of macro
(single-line and multi-line), and a ``context stack'' mechanism for
extra macro power. Preprocessor directives all begin with a \code{\%}
sign.

The preprocessor collapses all lines which end with a backslash
\code{\textbackslash\textbackslash} character into a single line.
Thus:

\begin{lstlisting}
	%define THIS_VERY_LONG_MACRO_NAME_IS_DEFINED_TO \\
	        THIS_VALUE
\end{lstlisting}

will work like a single-line macro without the backslash-newline
sequence.

\section{\textindexlc{Single-Line Macros}}
\label{sec:slmacro}

\subsection{The Normal Way: \indexcode{\%idefine}\codeindex{\%define}}
\label{subsec:define}

Single-line macros are defined using the \code{\%define} preprocessor
directive. The definitions work in a similar way to C; so you can do
things like

\begin{lstlisting}
	%define ctrl    0x1F &
	%define param(a,b) ((a)+(a)*(b))

		mov     byte [param(2,ebx)], ctrl 'D'
\end{lstlisting}

which will expand to

\begin{lstlisting}
	mov     byte [(2)+(2)*(ebx)], 0x1F & 'D'
\end{lstlisting}

When the expansion of a single-line macro contains tokens which
invoke another macro, the expansion is performed at invocation time,
not at definition time. Thus the code

\begin{lstlisting}
	%define a(x)    1+b(x)
	%define b(x)    2*x

	mov     ax,a(8)
\end{lstlisting}

will evaluate in the expected way to \code{mov ax,1+2*8}, even though
the macro \code{b} wasn't defined at the time of definition of \code{a}.

Macros defined with \code{\%define} are \textindex{case sensitive}: after
\code{\%define foo bar}, only \code{foo} will expand to \code{bar}:
\code{Foo} or \code{FOO} will not. By using \code{\%idefine} instead of
\code{\%define} (the ``i'' stands for ``insensitive'') you can define
all the case variants of a macro at once, so that \code{\%idefine foo bar}
would cause \code{foo}, \code{Foo}, \code{FOO}, \code{fOO} and so on
all to expand to \code{bar}.

There is a mechanism which detects when a macro call has occurred as
a result of a previous expansion of the same macro, to guard against
\textindex{circular references} and infinite loops. If this happens,
the preprocessor will only expand the first occurrence of the macro.
Hence, if you code

\begin{lstlisting}
	%define a(x)    1+a(x)

		mov     ax,a(3)
\end{lstlisting}

the macro \code{a(3)} will expand once, becoming \code{1+a(3)}, and will
then expand no further. This behaviour can be useful: see \fullref{sec:32c}
for an example of its use.

You can \index{overloading, single-line macros}overload single-line
macros: if you write

\begin{lstlisting}
	%define foo(x)   1+x
	%define foo(x,y) 1+x*y
\end{lstlisting}

the preprocessor will be able to handle both types of macro call,
by counting the parameters you pass; so \code{foo(3)} will become
\code{1+3} whereas \code{foo(ebx,2)} will become \code{1+ebx*2}.
However, if you define

\begin{lstlisting}
	%define foo bar
\end{lstlisting}

then no other definition of \code{foo} will be accepted: a macro with
no parameters prohibits the definition of the same name as a macro
\emph{with} parameters, and vice versa.

This doesn't prevent single-line macros being \emph{redefined}:
you can perfectly well define a macro with

\begin{lstlisting}
	%define foo bar
\end{lstlisting}

and then re-define it later in the same source file with

\begin{lstlisting}
	%define foo baz
\end{lstlisting}

Then everywhere the macro \code{foo} is invoked, it will be expanded
according to the most recent definition. This is particularly useful
when defining single-line macros with \code{\%assign}
(see \fullref{sec:assign}).

You can \textindex{pre-define} single-line macros using the \code{-d}
option on the NASM command line: see \fullref{subsec:opt-d}.

\subsection{Resolving \code{\%define}: \indexcode{\%ixdefine}\codeindex{\%xdefine}}
\label{subsec:xdefine}

To have a reference to an embedded single-line macro resolved at the
time that the embedding macro is \emph{defined}, as opposed to when the
embedding macro is \emph{expanded}, you need a different mechanism to the
one offered by \code{\%define}. The solution is to use \code{\%xdefine}, or
it's \index{case sensitive}case-insensitive counterpart \code{\%ixdefine}.

Suppose you have the following code:

\begin{lstlisting}
	%define  isTrue  1
	%define  isFalse isTrue
	%define  isTrue  0

	val1:    db      isFalse

	%define  isTrue  1

	val2:    db      isFalse
\end{lstlisting}

In this case, \code{val1} is equal to 0, and \code{val2} is equal to 1.
This is because, when a single-line macro is defined using \code{\%define},
it is expanded only when it is called. As \code{isFalse} expands to \code{isTrue},
the expansion will be the current value of \c{isTrue}. The first time it is called
that is 0, and the second time it is 1.

If you wanted \code{isFalse} to expand to the value assigned to the
embedded macro \code{isTrue} at the time that \code{isFalse} was defined,
you need to change the above code to use \code{\%xdefine}.

\begin{lstlisting}
	%xdefine isTrue  1
	%xdefine isFalse isTrue
	%xdefine isTrue  0

	val1:    db      isFalse

	%xdefine isTrue  1

	val2:    db      isFalse
\end{lstlisting}

Now, each time that \code{isFalse} is called, it expands to 1,
as that is what the embedded macro \code{isTrue} expanded to at
the time that \c{isFalse} was defined.

\subsection{\textindexlc{Macro Indirection}: \indexcode{\%[}\code{\%[...]}}
\label{subsec:indmacro}

The \code{\%[...]} construct can be used to expand macros in contexts
where macro expansion would otherwise not occur, including in the
names other macros. For example, if you have a set of macros named
\code{Foo16}, \code{Foo32} and \code{Foo64}, you could write:

\begin{lstlisting}
	mov ax,Foo%[__BITS__]	; The Foo value
\end{lstlisting}

to use the builtin macro \code{\_\_BITS\_\_} (see \fullref{sec:bitsm})
to automatically select between them. Similarly, the two statements:

\begin{lstlisting}
	%xdefine Bar		Quux	; Expands due to %xdefine
	%define  Bar		%[Quux]	; Expands due to %[...]
\end{lstlisting}

have, in fact, exactly the same effect.

\code{\%[...]} concatenates to adjacent tokens in the same way that
multi-line macro parameters do, see \fullref{sec:concat} for details.

\subsection{Concatenating Single Line Macro Tokens: \codeindex{\%+}}
\label{subsec:concat_macro}

Individual tokens in single line macros can be concatenated, to produce
longer tokens for later processing. This can be useful if there are
several similar macros that perform similar functions.

Please note that a space is required after \code{\%+}, in order to
disambiguate it from the syntax \code{\%+1} used in multiline macros.

As an example, consider the following:

\begin{lstlisting}
	%define BDASTART 400h                ; Start of BIOS data area

	struc   tBIOSDA                      ; its structure
		.COM1addr       RESW    1
		.COM2addr       RESW    1
		; ..and so on
	endstruc
\end{lstlisting}

Now, if we need to access the elements of tBIOSDA in different places,
we can end up with:

\begin{lstlisting}
	mov     ax,BDASTART + tBIOSDA.COM1addr
	mov     bx,BDASTART + tBIOSDA.COM2addr
\end{lstlisting}

This will become pretty ugly (and tedious) if used in many places, and
can be reduced in size significantly by using the following macro:

\begin{lstlisting}
	; Macro to access BIOS variables by their names (from tBDA):

	%define BDA(x)  BDASTART + tBIOSDA. %+ x
\end{lstlisting}

Now the above code can be written as:

\begin{lstlisting}
	mov     ax,BDA(COM1addr)
	mov     bx,BDA(COM2addr)
\end{lstlisting}

Using this feature, we can simplify references to a lot of macros
(and, in turn, reduce typing errors).
