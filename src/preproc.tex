\chapter{The NASM \textindexlc{Preprocessor}}
\label{ch:preproc}

NASM contains a powerful \textindex{macro processor}, which supports
conditional assembly, multi-level file inclusion, two forms of macro
(single-line and multi-line), and a ``context stack'' mechanism for
extra macro power. Preprocessor directives all begin with a \code{\%}
sign.

The preprocessor collapses all lines which end with a backslash
\code{\textbackslash\textbackslash} character into a single line.
Thus:

\begin{lstlisting}
%define THIS_VERY_LONG_MACRO_NAME_IS_DEFINED_TO \\
        THIS_VALUE
\end{lstlisting}

will work like a single-line macro without the backslash-newline
sequence.

\section{\textindexlc{Single-Line Macros}}
\label{sec:slmacro}

\subsection{The Normal Way: \indexcode{\%idefine}\codeindex{\%define}}
\label{subsec:define}

Single-line macros are defined using the \code{\%define} preprocessor
directive. The definitions work in a similar way to C; so you can do
things like

\begin{lstlisting}
%define ctrl    0x1F &
%define param(a,b) ((a)+(a)*(b))

        mov     byte [param(2,ebx)], ctrl 'D'
\end{lstlisting}

which will expand to

\begin{lstlisting}
        mov     byte [(2)+(2)*(ebx)], 0x1F & 'D'
\end{lstlisting}

When the expansion of a single-line macro contains tokens which
invoke another macro, the expansion is performed at invocation time,
not at definition time. Thus the code

\begin{lstlisting}
%define a(x)    1+b(x)
%define b(x)    2*x

        mov     ax,a(8)
\end{lstlisting}

will evaluate in the expected way to \code{mov ax,1+2*8}, even though
the macro \code{b} wasn't defined at the time of definition of \code{a}.

Macros defined with \code{\%define} are \textindex{case sensitive}: after
\code{\%define foo bar}, only \code{foo} will expand to \code{bar}:
\code{Foo} or \code{FOO} will not. By using \code{\%idefine} instead of
\code{\%define} (the ``i'' stands for ``insensitive'') you can define
all the case variants of a macro at once, so that \code{\%idefine foo bar}
would cause \code{foo}, \code{Foo}, \code{FOO}, \code{fOO} and so on
all to expand to \code{bar}.

There is a mechanism which detects when a macro call has occurred as
a result of a previous expansion of the same macro, to guard against
\textindex{circular references} and infinite loops. If this happens,
the preprocessor will only expand the first occurrence of the macro.
Hence, if you code

\begin{lstlisting}
%define a(x)    1+a(x)

        mov     ax,a(3)
\end{lstlisting}

the macro \code{a(3)} will expand once, becoming \code{1+a(3)}, and will
then expand no further. This behaviour can be useful: see \fullref{sec:32c}
for an example of its use.

You can \index{overloading, single-line macros}overload single-line
macros: if you write

\begin{lstlisting}
%define foo(x)   1+x
%define foo(x,y) 1+x*y
\end{lstlisting}

the preprocessor will be able to handle both types of macro call,
by counting the parameters you pass; so \code{foo(3)} will become
\code{1+3} whereas \code{foo(ebx,2)} will become \code{1+ebx*2}.
However, if you define

\begin{lstlisting}
%define foo bar
\end{lstlisting}

then no other definition of \code{foo} will be accepted: a macro with
no parameters prohibits the definition of the same name as a macro
\emph{with} parameters, and vice versa.

This doesn't prevent single-line macros being \emph{redefined}:
you can perfectly well define a macro with

\begin{lstlisting}
%define foo bar
\end{lstlisting}

and then re-define it later in the same source file with

\begin{lstlisting}
%define foo baz
\end{lstlisting}

Then everywhere the macro \code{foo} is invoked, it will be expanded
according to the most recent definition. This is particularly useful
when defining single-line macros with \code{\%assign}
(see \fullref{sec:assign}).

You can \textindex{pre-define} single-line macros using the \code{-d}
option on the NASM command line: see \fullref{subsec:opt-d}.

\subsection{Resolving \code{\%define}: \indexcode{\%ixdefine}\codeindex{\%xdefine}}
\label{subsec:xdefine}

To have a reference to an embedded single-line macro resolved at the
time that the embedding macro is \emph{defined}, as opposed to when the
embedding macro is \emph{expanded}, you need a different mechanism to the
one offered by \code{\%define}. The solution is to use \code{\%xdefine}, or
it's \index{case sensitive}case-insensitive counterpart \code{\%ixdefine}.

Suppose you have the following code:

\begin{lstlisting}
%define  isTrue  1
%define  isFalse isTrue
%define  isTrue  0

val1:    db      isFalse

%define  isTrue  1

val2:    db      isFalse
\end{lstlisting}

In this case, \code{val1} is equal to 0, and \code{val2} is equal to 1.
This is because, when a single-line macro is defined using \code{\%define},
it is expanded only when it is called. As \code{isFalse} expands to \code{isTrue},
the expansion will be the current value of \c{isTrue}. The first time it is called
that is 0, and the second time it is 1.

If you wanted \code{isFalse} to expand to the value assigned to the
embedded macro \code{isTrue} at the time that \code{isFalse} was defined,
you need to change the above code to use \code{\%xdefine}.

\begin{lstlisting}
%xdefine isTrue  1
%xdefine isFalse isTrue
%xdefine isTrue  0

val1:    db      isFalse

%xdefine isTrue  1

val2:    db      isFalse
\end{lstlisting}

Now, each time that \code{isFalse} is called, it expands to 1,
as that is what the embedded macro \code{isTrue} expanded to at
the time that \c{isFalse} was defined.

% FIXME the keys
\subsection{\textindexlc{Macro Indirection}: \indexcode{\%[}\code{\%[...]}}
\label{subsec:indmacro}

The \code{\%[...]} construct can be used to expand macros in contexts
where macro expansion would otherwise not occur, including in the
names other macros. For example, if you have a set of macros named
\code{Foo16}, \code{Foo32} and \code{Foo64}, you could write:

\begin{lstlisting}
mov ax,Foo%[__BITS__]	; The Foo value
\end{lstlisting}

to use the builtin macro \code{\_\_BITS\_\_} (see \fullref{sec:bitsm})
to automatically select between them. Similarly, the two statements:

\begin{lstlisting}
%xdefine Bar		Quux	; Expands due to %xdefine
%define  Bar		%[Quux]	; Expands due to %[...]
\end{lstlisting}

have, in fact, exactly the same effect.

\code{\%[...]} concatenates to adjacent tokens in the same way that
multi-line macro parameters do, see \fullref{sec:concat} for details.

% FIXME concat_macro key
\subsection{Concatenating Single Line Macro Tokens: \codeindex{\%+}}
\label{subsec:concat_macro}

Individual tokens in single line macros can be concatenated, to produce
longer tokens for later processing. This can be useful if there are
several similar macros that perform similar functions.

Please note that a space is required after \code{\%+}, in order to
disambiguate it from the syntax \code{\%+1} used in multiline macros.

As an example, consider the following:

\begin{lstlisting}
%define BDASTART 400h                ; Start of BIOS data area

struc   tBIOSDA                      ; its structure
        .COM1addr       RESW    1
        .COM2addr       RESW    1
        ; ..and so on
endstruc
\end{lstlisting}

Now, if we need to access the elements of tBIOSDA in different places,
we can end up with:

\begin{lstlisting}
mov     ax,BDASTART + tBIOSDA.COM1addr
mov     bx,BDASTART + tBIOSDA.COM2addr
\end{lstlisting}

This will become pretty ugly (and tedious) if used in many places, and
can be reduced in size significantly by using the following macro:

\begin{lstlisting}
; Macro to access BIOS variables by their names (from tBDA):

%define BDA(x)  BDASTART + tBIOSDA. %+ x
\end{lstlisting}

Now the above code can be written as:

\begin{lstlisting}
mov     ax,BDA(COM1addr)
mov     bx,BDA(COM2addr)
\end{lstlisting}

Using this feature, we can simplify references to a lot of macros
(and, in turn, reduce typing errors).

% FIXME they key
\subsection{The Macro Name Itself: \codeindex{\%?} and \codeindex{\%??}}
\label{subsec:selfref}

The special symbols \code{\%?} and \code{\%??} can be used to
reference the macro name itself inside a macro expansion,
this is supported for both single-and multi-line macros.
\code{\%?} refers to the macro name as \emph{invoked}, whereas
\code{\%??} refers to the macro name as \emph{declared}.
The two are always the same for case-sensitive macros, but
for case-insensitive macros, they can differ.

For example:

\begin{lstlisting}
%idefine Foo mov %?,%??

        foo
        FOO
\end{lstlisting}

will expand to:

\begin{lstlisting}
        mov foo,Foo
        mov FOO,Foo
\end{lstlisting}

The sequence:

\begin{lstlisting}
%idefine keyword $%?
\end{lstlisting}

can be used to make a keyword ``disappear'', for example in case a new
instruction has been used as a label in older code.  For example:

\begin{lstlisting}
%idefine pause $%?		; Hide the PAUSE instruction
\end{lstlisting}

\subsection{Undefining Single-Line Macros: \codeindex{\%undef}}
\label{subsec:undef}

Single-line macros can be removed with the \code{\%undef} directive.
For example, the following sequence:

\begin{lstlisting}
%define foo bar
%undef  foo

        mov     eax, foo
\end{lstlisting}

will expand to the instruction \code{mov eax, foo}, since after
\code{\%undef} the macro \code{foo} is no longer defined.

Macros that would otherwise be pre-defined can be undefined on the
command-line using the \code{-u} option on the NASM command line:
see \fullref{subsec:opt-u}.

\subsection{\textindex{Preprocessor Variables}: \codeindex{\%assign}}
\label{subsec:assign}

An alternative way to define single-line macros is by means of the
\code{\%assign} command (and its \index{case sensitive}case-insensitive
counterpart \codeindex{\%iassign}, which differs from \code{\%assign} in
exactly the same way that \code{\%idefine} differs from \code{\%define}).

\code{\%assign} is used to define single-line macros which take no
parameters and have a numeric value. This value can be specified in
the form of an expression, and it will be evaluated once, when the
\code{\%assign} directive is processed.

Like \code{\%define}, macros defined using \code{\%assign} can be
re-defined later, so you can do things like

\begin{lstlisting}
%assign i i+1
\end{lstlisting}

to increment the numeric value of a macro.

\code{\%assign} is useful for controlling the termination of \code{\%rep}
preprocessor loops: see \fullref{subsec:rep} for an example of this. Another
use for \code{\%assign} is given in \fullref{subsec:16c} and
\fullref{subse:32c}.

The expression passed to \code{\%assign} is a \textindex{critical expression}
(see \fullref{sec:crit}), and must also evaluate to a pure number
(rather than a relocatable reference such as a code or data address,
or anything involving a register).

\subsection{Defining Strings: \indexcode{\%idefstr}\codeindex{\%defstr}}
\label{subsec:defstr}

\code{\%defstr}, and its case-insensitive counterpart \code{\%idefstr},
define or redefine a single-line macro without parameters but converts
the entire right-hand side, after macro expansion, to a quoted string
before definition.

For example:

\begin{lstlisting}
%defstr test TEST
\end{lstlisting}

is equivalent to

\begin{lstlisting}
%define test 'TEST'
\end{lstlisting}

This can be used, for example, with the \code{\%!} construct
(see \fullref{subsec:getenv}):

\begin{lstlisting}
%defstr PATH %!PATH          ; The operating system PATH variable
\end{lstlisting}

\subsection{Defining Tokens: \indexcode{\%ideftok}\codeindex{\%deftok}}
\label{subsec:deftok}

\code{\%deftok}, and its case-insensitive counterpart \code{\%ideftok},
define or redefine a single-line macro without parameters but converts
the second parameter, after string conversion, to a sequence of tokens.

For example:

\begin{lstlisting}
%deftok test 'TEST'
\end{lstlisting}

is equivalent to

\begin{lstlisting}
%define test TEST
\end{lstlisting}

\section{\textindexlc{String Manipulation in Macros}}
\label{sec:strlen}

It's often useful to be able to handle strings in macros. NASM
supports a few simple string handling macro operators from which
more complex operations can be constructed.

All the string operators define or redefine a value (either a string
or a numeric value) to a single-line macro. When producing a string
value, it may change the style of quoting of the input string or
strings, and possibly use \code{\textbackslash}-escapes inside
\code{`}-quoted strings.

\subsection{\textindexlc{Concatenating Strings}: \codeindex{\%strcat}}
\label{subsec:strcat}

The \code{\%strcat} operator concatenates quoted strings and assign
them to a single-line macro.

For example:

\begin{lstlisting}
%strcat alpha "Alpha: ", '12" screen'
\end{lstlisting}

would assign the value \code{'Alpha: 12" screen'} to \code{alpha}.
Similarly:

\begin{lstlisting}
%strcat beta '"foo"\', "'bar'"
\end{lstlisting}

would assign the value \code{`"foo" \textbackslash \textbackslash 'bar'`}
to \code{beta}.

The use of commas to separate strings is permitted but optional.

\subsection{\textindexlc{String Length}: \codeindex{\%strlen}}
\label{subsec:strlen}

The \code{\%strlen} operator assigns the length of a string to a macro.
For example:

\begin{lstlisting}
%strlen charcnt 'my string'
\end{lstlisting}

In this example, \code{charcnt} would receive the value 9, just as
if an \code{\%assign} had been used. In this example, \code{'my string'}
was a literal string but it could also have been a single-line
macro that expands to a string, as in the following example:

\begin{lstlisting}
%define sometext 'my string'
%strlen charcnt sometext
\end{lstlisting}

As in the first case, this would result in \code{charcnt} being
assigned the value of 9.

\subsection{\textindexlc{Extracting Substrings}: \codeindex{\%substr}}
\label{subsec:substr}

Individual letters or substrings in strings can be extracted using the
\code{\%substr} operator. An example of its use is probably more useful
than the description:

\begin{lstlisting}
%substr mychar 'xyzw' 1     ; equivalent to %define mychar 'x'
%substr mychar 'xyzw' 2     ; equivalent to %define mychar 'y'
%substr mychar 'xyzw' 3     ; equivalent to %define mychar 'z'
%substr mychar 'xyzw' 2,2   ; equivalent to %define mychar 'yz'
%substr mychar 'xyzw' 2,-1  ; equivalent to %define mychar 'yzw'
%substr mychar 'xyzw' 2,-2  ; equivalent to %define mychar 'yz'
\end{lstlisting}

As with \code{\%strlen} (see \fullref{subsec:strlen}), the first
parameter is the single-line macro to be created and the second
is the string. The third parameter specifies the first character
to be selected, and the optional fourth parameter (preceeded by comma)
is the length. Note that the first index is 1, not 0 and the last
index is equal to the value that \code{\%strlen} would assign given
the same string. Index values out of range result in an empty string.
A negative length means ``until N-1 characters before the end of string'',
i.e. \code{-1} means until end of string, \code{-2} until one character
before, etc.

\section{\textindexlc{Multi-Line Macros}: \indexcode{\%imacro}\codeindex{\%macro}}
\label{sec:mlmacro}

Multi-line macros are much more like the type of macro seen in MASM
and TASM: a multi-line macro definition in NASM looks something like
this.

\begin{lstlisting}
%macro  prologue 1

        push    ebp
        mov     ebp,esp
        sub     esp,%1

%endmacro
\end{lstlisting}

This defines a C-like function prologue as a macro: so you would
invoke the macro with a call such as

\begin{lstlisting}
myfunc:   prologue 12
\end{lstlisting}

which would expand to the three lines of code

\begin{lstlisting}
myfunc: push    ebp
        mov     ebp,esp
        sub     esp,12
\end{lstlisting}

The number \code{1} after the macro name in the \code{\%macro} line
defines the number of parameters the macro \code{prologue} expects
to receive. The use of \code{\%1} inside the macro definition refers
to the first parameter to the macro call. With a macro taking more
than one parameter, subsequent parameters would be referred to as
\code{\%2}, \code{\%3} and so on.

Multi-line macros, like single-line macros, are \textindex{case-sensitive},
unless you define them using the alternative directive \code{\%imacro}.

If you need to pass a comma as \emph{part} of a parameter to a
multi-line macro, you can do that by enclosing the entire parameter
in \index{braces, around macro parameters}braces. So you could code
things like

\begin{lstlisting}
%macro  silly 2

    %2: db      %1

%endmacro

        silly 'a', letter_a             ; letter_a:  db 'a'
        silly 'ab', string_ab           ; string_ab: db 'ab'
        silly {13,10}, crlf             ; crlf:      db 13,10
\end{lstlisting}

\subsection{Overloading Multi-Line Macros\index{overloading, multi-line macros}}
\label{subsec:mlmacover}

As with single-line macros, multi-line macros can be overloaded by
defining the same macro name several times with different numbers of
parameters. This time, no exception is made for macros with no
parameters at all. So you could define

\begin{lstlisting}
%macro  prologue 0

        push    ebp
        mov     ebp,esp

%endmacro
\end{lstlisting}

to define an alternative form of the function prologue which
allocates no local stack space.

Sometimes, however, you might want to ``overload'' a machine
instruction; for example, you might want to define

\begin{lstlisting}
%macro  push 2

        push    %1
        push    %2

%endmacro
\end{lstlisting}

so that you could code

\begin{lstlisting}
        push    ebx             ; this line is not a macro call
        push    eax,ecx         ; but this one is
\end{lstlisting}

Ordinarily, NASM will give a warning for the first of the above two
lines, since \code{push} is now defined to be a macro, and is being
invoked with a number of parameters for which no definition has been
given. The correct code will still be generated, but the assembler
will give a warning. This warning can be disabled by the use of the
\code{-w-macro-params} command-line option (see \fullref{subsec:opt-w}).

\subsection{\textindexlc{Macro-Local Labels}}
\label{subsec:maclocal}

NASM allows you to define labels within a multi-line macro definition
in such a way as to make them local to the macro call: so calling
the same macro multiple times will use a different label each time.
You do this by prefixing \codeindex{\%\%} to the label name.
So you can invent an instruction which executes a \code{RET} if the
\code{Z} flag is set by doing this:

\begin{lstlisting}
%macro  retz 0

        jnz     %%skip
        ret
    %%skip:

%endmacro
\end{lstlisting}

You can call this macro as many times as you want, and every time
you call it NASM will make up a different ``real'' name to substitute
for the label \code{\%\%skip}. The names NASM invents are of the form
\code{..@2345.skip}, where the number 2345 changes with every macro
call. The \codeindex{..@} prefix prevents macro-local labels from
interfering with the local label mechanism, as described in
\fullref{subsec:locallab}. You should avoid defining your own labels
in this form (the \code{..@} prefix, then a number, then another period)
in case they interfere with macro-local labels.
