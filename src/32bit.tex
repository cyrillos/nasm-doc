%
% vim: ts=4 sw=4 et
%
\xchapter{32bit}{Writing 32-bit Code (Unix, Win32, DJGPP)}

This chapter attempts to cover some of the common issues involved
when writing 32-bit code, to run under \textindex{Win32} or Unix,
or to be linked with C code generated by a Unix-style C compiler such as
\textindex{DJGPP}. It covers how to write assembly code to interface with
32-bit C routines, and how to write position-independent code for
shared libraries.

Almost all 32-bit code, and in particular all code running under
\code{Win32}, \code{DJGPP} or any of the PC Unix variants, runs in
\index{flat memory model}\emph{flat} memory model. This means that
the segment registers and paging have already been set up to give
you the same 32-bit 4Gb address space no matter what segment you
work relative to, and that you should ignore all segment registers
completely. When writing flat-model application code, you never
need to use a segment override or modify any segment register,
and the code-section addresses you pass to \code{CALL} and
\code{JMP} live in the same address space as the data-section addresses
you access your variables by and the stack-section addresses you access
local variables and procedure parameters by. Every address is 32 bits
long and contains only an offset part.

\xsection{32c}{Interfacing to 32-bit C Programs}

A lot of the discussion in \fullref{sec:16c}, about interfacing to
16-bit C programs, still applies when working in 32 bits. The absence of
memory models or segmentation worries simplifies things a lot.

\xsubsection{32cunder}{External Symbol Names}

Most 32-bit C compilers share the convention used by 16-bit
compilers, that the names of all global symbols (functions or data)
they define are formed by prefixing an underscore to the name as it
appears in the C program. However, not all of them do: the \code{ELF}
specification states that C symbols do \emph{not} have a leading
underscore on their assembly-language names.

The older Linux \code{a.out} C compiler, all \code{Win32} compilers,
\code{DJGPP}, and \code{NetBSD} and \code{FreeBSD}, all use the leading
underscore; for these compilers, the macros \code{cextern} and
\code{cglobal}, as given in \fullref{subsec:16cunder}, will still work.
For \code{ELF}, though, the leading underscore should not be used.

See also \fullref{subsec:opt-pfix}.

\xsubsection{32cfunc}{Function Definitions and Function Calls}

\index{functions!C calling convention}The \textindex{C calling convention}
in 32-bit programs is as follows. In the following description,
the words \emph{caller} and \emph{callee} are used to denote
the function doing the calling and the function which gets called.

\begin{itemize}
    \item{The caller pushes the function's parameters on the stack, one
        after another, in reverse order (right to left, so that the first
        argument specified to the function is pushed last).}

    \item{The caller then executes a near \code{CALL} instruction to pass
        control to the callee.}

    \item{The callee receives control, and typically (although this
        is not actually necessary, in functions which do not need to
        access their parameters) starts by saving the value of \code{ESP}
        in \code{EBP} so as to be able to use \code{EBP} as a base pointer
        to find its parameters on the stack. However, the caller was
        probably doing this too, so part of the calling convention states
        that \code{EBP} must be preserved by any C function. Hence the
        callee, if it is going to set up \code{EBP} as a \textindex{frame
        pointer}, must push the previous value first.}

    \item{The callee may then access its parameters relative to \code{EBP}.
        The doubleword at \code{[EBP]} holds the previous value of
        \code{EBP} as it was pushed; the next doubleword, at \code{[EBP+4]},
        holds the return address, pushed implicitly by \code{CALL}.
        The parameters start after that, at \code{[EBP+8]}. The leftmost
        parameter of the function, since it was pushed last, is accessible
        at this offset from \code{EBP}; the others follow, at successively
        greater offsets. Thus, in a function such as \code{printf} which
        takes a variable number of parameters, the pushing of the
        parameters in reverse order means that the function knows where
        to find its first parameter, which tells it the number and type
        of the remaining ones.}

    \item{The callee may also wish to decrease \code{ESP} further, so as
        to allocate space on the stack for local variables, which will
        then be accessible at negative offsets from \code{EBP}.}

    \item{The callee, if it wishes to return a value to the caller,
        should leave the value in \code{AL}, \code{AX} or \code{EAX}
        depending on the size of the value. Floating-point results
        are typically returned in \code{ST0}.}

    \item{Once the callee has finished processing, it restores 
        \code{ESP} from \c{EBP} if it had allocated local stack space,
        then pops the previous value of \code{EBP}, and returns via
        \code{RET} (equivalently, \code{RETN}).}

    \item{When the caller regains control from the callee, the function
        parameters are still on the stack, so it typically adds an
        immediate constant to \code{ESP} to remove them (instead of
        executing a number of slow \code{POP} instructions). Thus,
        if a function is accidentally called with the wrong number
        of parameters due to a prototype mismatch, the stack will
        still be returned to a sensible state since the caller, which
        \emph{knows} how many parameters it pushed, does the
        removing.}
\end{itemize}

There is an alternative calling convention used by Win32 programs
for Windows API calls, and also for functions called \emph{by} the
Windows API such as window procedures: they follow what Microsoft
calls the \code{\_\_stdcall} convention. This is slightly closer to the
Pascal convention, in that the callee clears the stack by passing a
parameter to the \code{RET} instruction. However, the parameters are
still pushed in right-to-left order.

Thus, you would define a function in C style in the following way:

\begin{lstlisting}
global  _myfunc

_myfunc:
    push    ebp
    mov     ebp,esp
    sub     esp,0x40        ; 64 bytes of local stack space
    mov     ebx,[ebp+8]     ; first parameter to function

    ; some more code

    leave                   ; mov esp,ebp / pop ebp
    ret
\end{lstlisting}

At the other end of the process, to call a C function from your
assembly code, you would do something like this:

\begin{lstlisting}
extern  _printf

    ; and then, further down...

    push    dword [myint]   ; one of my integer variables
    push    dword mystring  ; pointer into my data segment
    call    _printf
    add     esp,byte 8      ; `byte' saves space

    ; then those data items...

segment _DATA

myint       dd  1234
mystring    db  'This number -> %d <- should be 1234',10,0
\end{lstlisting}

This piece of code is the assembly equivalent of the C code

\begin{lstlisting}
    int myint = 1234;
    printf("This number -> %d <- should be 1234\n", myint);
\end{lstlisting}

\xsubsection{32cdata}{Accessing Data Items}

To get at the contents of C variables, or to declare variables which
C can access, you need only declare the names as \code{GLOBAL} or
\code{EXTERN}. (Again, the names require leading underscores, as stated
in \fullref{subsec:32cunder}.) Thus, a C variable declared as \code{int i}
can be accessed from assembler as

\begin{lstlisting}
    extern _i
    mov eax,[_i]
\end{lstlisting}

And to declare your own integer variable which C programs can access
as \code{extern int j}, you do this (making sure you are assembling in
the \code{\_DATA} segment, if necessary):

\begin{lstlisting}
    global _j
_j  dd 0
\end{lstlisting}

To access a C array, you need to know the size of the components of
the array. For example, \code{int} variables are four bytes long, so if
a C program declares an array as \code{int a[10]}, you can access
\code{a[3]} by coding \code{mov ax,[\_a+12]}. (The byte offset 12 is
obtained by multiplying the desired array index, 3, by the size of
the array element, 4.) The sizes of the C base types in 32-bit compilers
are: 1 for \code{char}, 2 for \code{short}, 4 for \code{int}, \code{long}
and \code{float}, and 8 for \code{double}. Pointers, being 32-bit
addresses, are also 4 bytes long.

To access a C \textindex{data structure}, you need to know the offset from
the base of the structure to the field you are interested in. You
can either do this by converting the C structure definition into a
NASM structure definition (using \code{STRUC}), or by calculating the
one offset and using just that.

To do either of these, you should read your C compiler's manual to
find out how it organizes data structures. NASM gives no special
alignment to structure members in its own \codeindex{STRUC} macro,
so you have to specify alignment yourself if the C compiler generates it.
Typically, you might find that a structure like

\begin{lstlisting}
struct {
    char c;
    int i;
} foo;
\end{lstlisting}

might be eight bytes long rather than five, since the \code{int} field
would be aligned to a four-byte boundary. However, this sort of
feature is sometimes a configurable option in the C compiler, either
using command-line options or \code{\#pragma} lines, so you have to find
out how your own compiler does it.

\xsubsection{32cmacro}{\codeindex{c32.mac}: Helper Macros for the 32-bit C Interface}

Included in the NASM archives, in the \index{misc directory}\code{misc}
directory, is a file \code{c32.mac} of macros. It defines three macros:
\codeindex{proc}, \codeindex{arg} and \codeindex{endproc}. These are
intended to be used for C-style procedure definitions, and they automate
a lot of the work involved in keeping track of the calling convention.

An example of an assembly function using the macro set is given
here:

\begin{lstlisting}
proc    _proc32
%$i         arg
%$j         arg
    mov     eax,[ebp + %$i]
    mov     ebx,[ebp + %$j]
    add     eax,[ebx]
endproc
\end{lstlisting}

This defines \code{\_proc32} to be a procedure taking two arguments, the
first (\code{i}) an integer and the second (\code{j}) a pointer to an
integer. It returns \code{i + *j}.

Note that the \code{arg} macro has an \code{EQU} as the first line of its
expansion, and since the label before the macro call gets prepended
to the first line of the expanded macro, the \code{EQU} works, defining
\code{\%\$i} to be an offset from \code{BP}. A context-local variable is
used, local to the context pushed by the \code{proc} macro and popped
by the \code{endproc} macro, so that the same argument name can be used
in later procedures. Of course, you don't \emph{have} to do that.

\code{arg} can take an optional parameter, giving the size of the
argument. If no size is given, 4 is assumed, since it is likely that
many function parameters will be of type \code{int} or pointers.
