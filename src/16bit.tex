\chapter{Writing 16-bit Code (DOS, Windows 3/3.1)}
\label{ch:16bit}

This chapter attempts to cover some of the common issues encountered
when writing 16-bit code to run under \code{MS-DOS} or \code{Windows 3.x}.
It covers how to link programs to produce \code{.EXE} or \code{.COM} files,
how to write \code{.SYS} device drivers, and how to interface assembly
language code with 16-bit C compilers and with Borland Pascal.

\section{Producing \codeindex{.EXE} Files}
\label{sec:exefiles}

Any large program written under DOS needs to be built as a \code{.EXE}
file: only \code{.EXE} files have the necessary internal structure
required to span more than one 64K segment. \textindex{Windows} programs,
also, have to be built as \code{.EXE} files, since Windows does not
support the \code{.COM} format.

In general, you generate \code{.EXE} files by using the \code{obj} output
format to produce one or more \codeindex{.OBJ} files, and then linking
them together using a linker. However, NASM also supports the direct
generation of simple DOS \code{.EXE} files using the \code{bin} output
format (by using \code{DB} and \code{DW} to construct the \code{.EXE} file
header), and a macro package is supplied to do this. Thanks to
Yann Guidon for contributing the code for this.

NASM may also support \code{.EXE} natively as another output format in
future releases.

\subsection{Using the \code{obj} Format To Generate \code{.EXE} Files}
\label{subsec:objexe}

This section describes the usual method of generating \code{.EXE} files
by linking \code{.OBJ} files together.

Most 16-bit programming language packages come with a suitable
linker; if you have none of these, there is a free linker called
\textindex{VALX}\index{linker!VALX}, available as a part of
CC386 compiler on \href{http://ladsoft.tripod.com/cc386\_compiler.html}
{ladsoft.tripod.com}.

There is another `free' linker (though this one doesn't come with
sources) called \textindex{FREELINK}\index{linker!FREELINK}, available
from \href{http://www.pcorner.com/tpc/old/3-101.html}{www.pcorner.com}.

A third, \textindex{djlink}, written by DJ Delorie, is available at
\href{http://www.delorie.com/djgpp/16bit/djlink/}{www.delorie.com}.

A fourth linker, \textindex{ALINK}\index{linker!ALINK}, written by
Anthony A.J. Williams, is available at \href{http://alink.sourceforge.net}
{alink.sourceforge.net}.

When linking several \code{.OBJ} files into a \code{.EXE} file, you should
ensure that exactly one of them has a start point defined (using the
\index{program entry point}\codeindex{..start} special symbol defined by the
\code{obj} format: see \fullref{sec:dotdotstart}). If no module defines a start
point, the linker will not know what value to give the entry-point
field in the output file header; if more than one defines a start
point, the linker will not know \emph{which} value to use.

An example of a NASM source file which can be assembled to a
\code{.OBJ} file and linked on its own to a \code{.EXE} is given here. It
demonstrates the basic principles of defining a stack, initialising
the segment registers, and declaring a start point. This file is
also provided in the \index{test subdirectory}\code{test} subdirectory of
the NASM archives, under the name \code{objexe.asm}.

\begin{lstlisting}
segment code

..start:
    mov     ax,data
    mov     ds,ax
    mov     ax,stack
    mov     ss,ax
    mov     sp,stacktop
\end{lstlisting}

This initial piece of code sets up \code{DS} to point to the data
segment, and initializes \code{SS} and \code{SP} to point to the top of
the provided stack. Notice that interrupts are implicitly disabled
for one instruction after a move into \code{SS}, precisely for this
situation, so that there's no chance of an interrupt occurring
between the loads of \code{SS} and \code{SP} and not having a stack to
execute on.

Note also that the special symbol \code{..start} is defined at the
beginning of this code, which means that will be the entry point
into the resulting executable file.

\begin{lstlisting}
    mov     dx,hello
    mov     ah,9
    int     0x21
\end{lstlisting}

The above is the main program: load \code{DS:DX} with a pointer to the
greeting message (\code{hello} is implicitly relative to the segment
\code{data}, which was loaded into \code{DS} in the setup code, so the
full pointer is valid), and call the DOS print-string function.

\begin{lstlisting}
    mov     ax,0x4c00
    int     0x21
\end{lstlisting}

This terminates the program using another DOS system call.

\begin{lstlisting}
segment data

hello:  db      'hello, world', 13, 10, '$'
\end{lstlisting}

The data segment contains the string we want to display.

\begin{lstlisting}
segment stack stack
    resb 64
stacktop:
\end{lstlisting}

The above code declares a stack segment containing 64 bytes of
uninitialized stack space, and points \code{stacktop} at the top of it.
The directive \code{segment stack stack} defines a segment \emph{called}
\code{stack}, and also of \emph{type} \code{STACK}. The latter is not
necessary to the correct running of the program, but linkers are
likely to issue warnings or errors if your program has no segment of
type \code{STACK}.

The above file, when assembled into a \code{.OBJ} file, will link on
its own to a valid \code{.EXE} file, which when run will print `hello,
world' and then exit.

\subsection{Using the \code{bin} Format To Generate \code{.EXE} Files}
\label{subsec:binexe}

The \code{.EXE} file format is simple enough that it's possible to
build a \code{.EXE} file by writing a pure-binary program and sticking
a 32-byte header on the front. This header is simple enough that it
can be generated using \code{DB} and \code{DW} commands by NASM itself,
so that you can use the \code{bin} output format to directly generate
\code{.EXE} files.

Included in the NASM archives, in the \index{misc subdirectory}\code{misc}
subdirectory, is a file \codeindex{exebin.mac} of macros. It defines three
macros: \codeindex{EXE\_begin}, \codeindex{EXE\_stack} and
\codeindex{EXE\_end}.

To produce a \code{.EXE} file using this method, you should start by
using \code{\%include} to load the \code{exebin.mac} macro package into
your source file. You should then issue the \code{EXE\_begin} macro call
(which takes no arguments) to generate the file header data. Then
write code as normal for the \code{bin} format - you can use all three
standard sections \code{.text}, \code{.data} and \code{.bss}. At the end of
the file you should call the \code{EXE\_end} macro (again, no arguments),
which defines some symbols to mark section sizes, and these symbols
are referred to in the header code generated by \code{EXE\_begin}.

In this model, the code you end up writing starts at \code{0x100}, just
like a \code{.COM} file - in fact, if you strip off the 32-byte header
from the resulting \code{.EXE} file, you will have a valid \code{.COM}
program. All the segment bases are the same, so you are limited to a
64K program, again just like a \code{.COM} file. Note that an \code{ORG}
directive is issued by the \code{EXE\_begin} macro, so you should not
explicitly issue one of your own.

You can't directly refer to your segment base value, unfortunately,
since this would require a relocation in the header, and things
would get a lot more complicated. So you should get your segment
base by copying it out of \code{CS} instead.

On entry to your \code{.EXE} file, \code{SS:SP} are already set up to
point to the top of a 2Kb stack. You can adjust the default stack
size of 2Kb by calling the \code{EXE\_stack} macro. For example, to
change the stack size of your program to 64 bytes, you would call
\code{EXE\_stack 64}.

A sample program which generates a \code{.EXE} file in this way is
given in the \code{test} subdirectory of the NASM archive, as
\code{binexe.asm}.

\section{Producing \codeindex{.COM} Files}
\label{sec:comfiles}

While large DOS programs must be written as \code{.EXE} files, small
ones are often better written as \code{.COM} files. \code{.COM} files are
pure binary, and therefore most easily produced using the \code{bin}
output format.

\subsection{Using the \code{bin} Format To Generate \code{.COM} Files}
\label{subsec:combinfmt}

\code{.COM} files expect to be loaded at offset \code{100h} into their
segment (though the segment may change). Execution then begins at
\indexcode{ORG}\code{100h}, i.e. right at the start of the program.
So to write a \code{.COM} program, you would create a source file
looking like

\begin{lstlisting}
        org 100h

section .text
start:
        ; put your code here

section .data
        ; put data items here

section .bss
        ; put uninitialized data here
\end{lstlisting}

The \code{bin} format puts the \code{.text} section first in the file,
so you can declare data or BSS items before beginning to write code if
you want to and the code will still end up at the front of the file
where it belongs.

The BSS (uninitialized data) section does not take up space in the
\code{.COM} file itself: instead, addresses of BSS items are resolved
to point at space beyond the end of the file, on the grounds that
this will be free memory when the program is run. Therefore you
should not rely on your BSS being initialized to all zeros when you
run.

To assemble the above program, you should use a command line like

\begin{lstlisting}
nasm myprog.asm -fbin -o myprog.com
\end{lstlisting}

The \code{bin} format would produce a file called \code{myprog} if no
explicit output file name were specified, so you have to override it
and give the desired file name.

\subsection{Using the \code{obj} Format To Generate \code{.COM} Files}
\label{subsec:comobjfmt}

If you are writing a \code{.COM} program as more than one module, you
may wish to assemble several \code{.OBJ} files and link them together
into a \code{.COM} program. You can do this, provided you have a linker
capable of outputting \code{.COM} files directly (\textindex{TLINK} does this),
or alternatively a converter program such as \codeindex{EXE2BIN} to
transform the \code{.EXE} file output from the linker into a \code{.COM}
file.

If you do this, you need to take care of several things:

\begin{itemize}
    \item{The first object file containing code should start its code
        segment with a line like \code{RESB 100h}. This is to ensure
        that the code begins at offset \code{100h} relative to the beginning
        of the code segment, so that the linker or converter program does
        not have to adjust address references within the file when generating
        the \code{.COM} file. Other assemblers use an \codeindex{ORG} directive
        for this purpose, but \code{ORG} in NASM is a format-specific directive
        to the \code{bin} output format, and does not mean the same thing as
        it does in MASM-compatible assemblers.}
    \item{You don't need to define a stack segment.}
    \item{All your segments should be in the same group, so that every time
        your code or data references a symbol offset, all offsets are
        relative to the same segment base. This is because, when a \code{.COM}
        file is loaded, all the segment registers contain the same value.}
\end{itemize}

\section{Producing \codeindex{.SYS} Files}
\label{sec:sysfiles}

\textindex{MS-DOS device drivers} - \code{.SYS} files - are pure binary files,
similar to \code{.COM} files, except that they start at origin zero
rather than \code{100h}. Therefore, if you are writing a device driver
using the \code{bin} format, you do not need the \code{ORG} directive,
since the default origin for \code{bin} is zero. Similarly, if you are
using \code{obj}, you do not need the \code{RESB 100h} at the start of
your code segment.

\code{.SYS} files start with a header structure, containing pointers to
the various routines inside the driver which do the work. This
structure should be defined at the start of the code segment, even
though it is not actually code.

For more information on the format of \code{.SYS} files, and the data
which has to go in the header structure, a list of books is given in
the Frequently Asked Questions list for the newsgroup
\href{news:comp.os.msdos.programmer}{comp.os.msdos.programmer}.

\section{Interfacing to 16-bit C Programs}
\label{sec:16c}

This section covers the basics of writing assembly routines that
call, or are called from, C programs. To do this, you would
typically write an assembly module as a \code{.OBJ} file, and link it
with your C modules to produce a \textindex{mixed-language program}.
