\chapter{\textindexlc{Output Formats}}
\label{ch:outfmt}

NASM is a portable assembler, designed to be able to compile on any
ANSI C-supporting platform and produce output to run on a variety of
Intel x86 operating systems. For this reason, it has a large number
of available output formats, selected using the \codeindex{-f} option
on the NASM \textindex{command line}. Each of these formats, along with
its extensions to the base NASM syntax, is detailed in this chapter.

\section{\codeindex{bin}: \textindexlc{Flat-Form Binary}\index{pure binary} Output}
\label{sec:binfmt}
\index{file extension!bin}

The \code{bin} format does not produce object files: it generates
nothing in the output file except the code you wrote. Such ``pure
binary'' files are used by \textindex{MS-DOS}: \codeindex{.COM}
executables and \codeindex{.SYS} device drivers are pure binary
files. Pure binary output is also useful for \textindex{operating system}
and \textindex{boot loader} development.

The \code{bin} format supports \textindex{multiple section names}.
For details of how NASM handles sections in the \code{bin} format,
see \fullref{sec:multisec}.

Using the \code{bin} format puts NASM by default into 16-bit mode
(see \fullref{sec:bits}). In order to use \code{bin} to write 32-bit
or 64-bit code, such as an OS kernel, you need to explicitly issue
the \indexcode{BITS}\c{BITS 32} or \indexcode{BITS}\c{BITS 64}
directive.

\code{bin} has no default output file name extension: instead, it
leaves your file name as it is once the original extension has been
removed. Thus, the default is for NASM to assemble \code{binprog.asm}
into a binary file called \code{binprog}.

\subsection{\codeindex{ORG}: Binary File \textindexlc{Program Origin}}
\label{subsec:binfmt}

The \code{bin} format provides an additional directive to the list
given in \fullref{sec:directive}: \code{ORG}. The function of the
\code{ORG} directive is to specify the origin address which NASM
will assume the program begins at when it is loaded into memory.

For example, the following code will generate the longword
\code{0x00000104}:

\begin{lstlisting}
    org     0x100
    dd      label
label:
\end{lstlisting}

Unlike the \code{ORG} directive provided by MASM-compatible assemblers,
which allows you to jump around in the object file and overwrite
code you have already generated, NASM's \code{ORG} does exactly what
the directive says: \emph{origin}. Its sole function is to specify one
offset which is added to all internal address references within the
section; it does not permit any of the trickery that MASM's version
does. See \fullref{sec:proborg} for further comments.

\subsection{\code{bin} Extensions to the \code{SECTION}
Directive\index{section!bin extensions to}}
\label{subsec:binseg}

The \code{bin} output format extends the \code{SECTION} (or \code{SEGMENT})
directive to allow you to specify the alignment requirements of segments.
This is done by appending the \codeindex{ALIGN} qualifier to the end of
the section-definition line. For example,

\begin{lstlisting}
section .data   align=16
\end{lstlisting}

switches to the section \code{.data} and also specifies that it must be
aligned on a 16-byte boundary.

The parameter to \code{ALIGN} specifies how many low bits of the
section start address must be forced to zero. The alignment value
given may be any power of two.\index{section alignment!in bin}
\index{segment alignment!in bin}\index{alignment!in bin sections}

\subsection{\textindexlc{Multisection}\index{bin!multisection} Support for the \code{bin} Format}
\label{subsec:multisec}

The \code{bin} format allows the use of multiple sections, of arbitrary names,
besides the ``known'' \code{.text}, \code{.data}, and \code{.bss} names.

\begin{itemize}
    \item{Sections may be designated \codeindex{progbits} or \codeindex{nobits}.
        Default is \code{progbits} (except \code{.bss}, which defaults to
        \code{nobits}, of course).}

    \item{Sections can be aligned at a specified boundary following the previous
        section with \code{align=}, or at an arbitrary byte-granular position with
        \codeindex{start=}.}

    \item{Sections can be given a virtual start address, which will be used
        for the calculation of all memory references within that section
        with \codeindex{vstart=}.}

    \item{Sections can be ordered using \codeindex{follows=}\code{<section>} or
        \codeindex{vfollows=}\code{<section>} as an alternative to specifying
        an explicit start address.}

    \item{Arguments to \code{org}, \code{start}, \code{vstart}, and \code{align=}
        are critical expressions. See \fullref{sec:crit}. E.g.
        \code{align=(1 << ALIGN\_SHIFT)} - \code{ALIGN\_SHIFT} must be defined
        before it is used here.}

    \item{Any code which comes before an explicit \code{SECTION} directive
        is directed by default into the \code{.text} section.}

    \item{If an \code{ORG} statement is not given, \code{ORG 0} is used by default.}

    \item{The \code{.bss} section will be placed after the last \code{progbits}
        section, unless \code{start=}, \code{vstart=}, \code{follows=}, or
        \code{vfollows=} has been specified.}

    \item{All sections are aligned on dword boundaries, unless a different
        alignment has been specified.}

    \item{Sections may not overlap.}

    \item{NASM creates the \code{section.<secname>.start} for each section,
        which may be used in your code.}
\end{itemize}

\subsection{\textindexlc{Map Files}}
\label{subsec:map}
\index{file extension!map}

Map files can be generated in \code{-f bin} format by means of the \code{[map]}
option. Map types of \code{all} (default), \code{brief}, \code{sections},
\code{segments}, or \code{symbols} may be specified. Output may be directed
to \code{stdout} (default), \code{stderr}, or a specified file. E.g.
\code{[map symbols myfile.map]}. No ``user form'' exists, the square
brackets must be used.

\section{\codeindex{ith}: \textindexlc{Intel Hex} Output}
\label{sec:ithfmt}
\index{file extension!ith}

The \code{ith} file format produces Intel hex-format files. Just as the
\code{bin} format, this is a flat memory image format with no support for
relocation or linking. It is usually used with ROM programmers and
similar utilities.

All extensions supported by the \code{bin} file format is also supported by
the \code{ith} file format.

\code{ith} provides a default output file-name extension of \code{.ith}.

\section{\codeindex{srec}: \textindexlc{Motorola S-Records} Output}
\label{sec:srecfmt}
\index{file extension!srec}

The \code{srec} file format produces Motorola S-records files. Just as the
\code{bin} format, this is a flat memory image format with no support for
relocation or linking. It is usually used with ROM programmers and similar
utilities.

All extensions supported by the \code{bin} file format is also supported by
the \code{srec} file format.

\code{srec} provides a default output file-name extension of \code{.srec}.

\section{\codeindex{obj}: \textindexlc{Microsoft OMF}\index{OMF} Object Files}
\label{sec:objfmt}
\index{file extension!obj}

The \code{obj} file format (NASM calls it \code{obj} rather than
\code{omf} for historical reasons) is the one produced by \textindex{MASM}
and \textindex{TASM}, which is typically fed to 16-bit DOS linkers
to produce \codeindex{.EXE} files. It is also the format used by
\textindex{OS/2}.

\code{obj} provides a default output file-name extension of \code{.obj}.

\code{obj} is not exclusively a 16-bit format, though: NASM has full
support for the 32-bit extensions to the format. In particular,
32-bit \code{obj} format files are used by \textindex{Borland's Win32
compilers}, instead of using Microsoft's newer \codeindex{win32} object
file format.

The \code{obj} format does not define any special segment names: you
can call your segments anything you like. Typical names for segments
in \code{obj} format files are \code{CODE}, \code{DATA} and \code{BSS}.

If your source file contains code before specifying an explicit
\code{SEGMENT} directive, then NASM will invent its own segment called
\codeindex{\_\_NASMDEFSEG} for you.

When you define a segment in an \code{obj} file, NASM defines the
segment name as a symbol as well, so that you can access the segment
address of the segment. So, for example:

\begin{lstlisting}
segment data

dvar:   dw      1234

segment code

function:
    mov     ax,data     ; get segment address of data
    mov     ds,ax       ; and move it into DS
    inc     word [dvar] ; now this reference will work
    ret
\end{lstlisting}

The \c{obj} format also enables the use of the \i\c{SEG} and
\i\c{WRT} operators, so that you can write code which does things
like

\begin{lstlisting}
extern  foo

    mov     ax,seg foo              ; get preferred segment of foo
    mov     ds,ax
    mov     ax,data                 ; a different segment
    mov     es,ax
    mov     ax,[ds:foo]             ; this accesses `foo'
    mov     [es:foo wrt data],bx    ; so does this
\end{lstlisting}
