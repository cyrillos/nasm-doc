\chapter{\textindexlc{Output Formats}}
\label{ch:outfmt}

NASM is a portable assembler, designed to be able to compile on any
ANSI C-supporting platform and produce output to run on a variety of
Intel x86 operating systems. For this reason, it has a large number
of available output formats, selected using the \codeindex{-f} option
on the NASM \textindex{command line}. Each of these formats, along with
its extensions to the base NASM syntax, is detailed in this chapter.

\section{\codeindex{bin}: \textindexlc{Flat-Form Binary}\index{pure binary} Output}
\label{sec:binfmt}

The \code{bin} format does not produce object files: it generates
nothing in the output file except the code you wrote. Such ``pure
binary'' files are used by \textindex{MS-DOS}: \codeindex{.COM}
executables and \codeindex{.SYS} device drivers are pure binary
files. Pure binary output is also useful for \textindex{operating system}
and \textindex{boot loader} development.

The \code{bin} format supports \textindex{multiple section names}.
For details of how NASM handles sections in the \code{bin} format,
see \fullref{sec:multisec}.

Using the \code{bin} format puts NASM by default into 16-bit mode
(see \fullref{sec:bits}). In order to use \code{bin} to write 32-bit
or 64-bit code, such as an OS kernel, you need to explicitly issue
the \indexcode{BITS}\c{BITS 32} or \indexcode{BITS}\c{BITS 64}
directive.

\code{bin} has no default output file name extension: instead, it
leaves your file name as it is once the original extension has been
removed. Thus, the default is for NASM to assemble \code{binprog.asm}
into a binary file called \code{binprog}.

\subsection{\codeindex{ORG}: Binary File \textindexlc{Program Origin}}
\label{subsec:binfmt}

The \code{bin} format provides an additional directive to the list
given in \fullref{sec:directive}: \code{ORG}. The function of the
\code{ORG} directive is to specify the origin address which NASM
will assume the program begins at when it is loaded into memory.

For example, the following code will generate the longword
\code{0x00000104}:

\begin{lstlisting}
    org     0x100
    dd      label
label:
\end{lstlisting}

Unlike the \code{ORG} directive provided by MASM-compatible assemblers,
which allows you to jump around in the object file and overwrite
code you have already generated, NASM's \code{ORG} does exactly what
the directive says: \emph{origin}. Its sole function is to specify one
offset which is added to all internal address references within the
section; it does not permit any of the trickery that MASM's version
does. See \fullref{sec:proborg} for further comments.

\subsection{\code{bin} Extensions to the \code{SECTION}
Directive\index{section!bin extensions to}}
\label{subsec:binseg}

The \code{bin} output format extends the \code{SECTION} (or \code{SEGMENT})
directive to allow you to specify the alignment requirements of segments.
This is done by appending the \codeindex{ALIGN} qualifier to the end of
the section-definition line. For example,

\begin{lstlisting}
section .data   align=16
\end{lstlisting}

switches to the section \code{.data} and also specifies that it must be
aligned on a 16-byte boundary.

The parameter to \code{ALIGN} specifies how many low bits of the
section start address must be forced to zero. The alignment value
given may be any power of two.\index{section alignment!in bin}
\index{segment alignment!in bin}\index{alignment!in bin sections}

\subsection{\textindexlc{Multisection}\index{bin!multisection} Support for the \code{bin} Format}
\label{subsec:multisec}

The \code{bin} format allows the use of multiple sections, of arbitrary names,
besides the ``known'' \code{.text}, \code{.data}, and \code{.bss} names.

\begin{itemize}
    \item{Sections may be designated \codeindex{progbits} or \codeindex{nobits}.
        Default is \code{progbits} (except \code{.bss}, which defaults to
        \code{nobits}, of course).}

    \item{Sections can be aligned at a specified boundary following the previous
        section with \code{align=}, or at an arbitrary byte-granular position with
        \codeindex{start=}.}

    \item{Sections can be given a virtual start address, which will be used
        for the calculation of all memory references within that section
        with \codeindex{vstart=}.}

    \item{Sections can be ordered using \codeindex{follows=}\code{<section>} or
        \codeindex{vfollows=}\code{<section>} as an alternative to specifying
        an explicit start address.}

    \item{Arguments to \code{org}, \code{start}, \code{vstart}, and \code{align=}
        are critical expressions. See \fullref{sec:crit}. E.g.
        \code{align=(1 << ALIGN\_SHIFT)} - \code{ALIGN\_SHIFT} must be defined
        before it is used here.}

    \item{Any code which comes before an explicit \code{SECTION} directive
        is directed by default into the \code{.text} section.}

    \item{If an \code{ORG} statement is not given, \code{ORG 0} is used by default.}

    \item{The \code{.bss} section will be placed after the last \code{progbits}
        section, unless \code{start=}, \code{vstart=}, \code{follows=}, or
        \code{vfollows=} has been specified.}

    \item{All sections are aligned on dword boundaries, unless a different
        alignment has been specified.}

    \item{Sections may not overlap.}

    \item{NASM creates the \code{section.<secname>.start} for each section,
        which may be used in your code.}
\end{itemize}
